<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/stevenvachon/broken-link-checker">broken-link-checker (v0.7.4)</a>
</h1>
<h4>Find broken links, missing images, etc in your HTML.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker">module broken-link-checker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlUrlChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>SiteChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>UrlChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlChecker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlUrlChecker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">broken-link-checker.</span>SiteChecker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">broken-link-checker.</span>UrlChecker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_EXTERNAL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_HTML</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_INTERNAL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_INVALID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_KEYWORD</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_ROBOTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_SAMEPAGE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_SCHEME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>BLC_UNKNOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EACCES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EADDRINFO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EADDRINUSE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EADDRNOTAVAIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EAFNOSUPPORT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EAGAIN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EAIFAMNOSUPPORT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EAISERVICE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EAISOCKTYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EALREADY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EBADF</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EBUSY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ECANCELED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ECHARSET</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ECONNABORTED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ECONNREFUSED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ECONNRESET</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EDESTADDRREQ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EEXIST</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EFAULT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EHOSTUNREACH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EINTR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EINVAL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EIO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EISCONN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EISDIR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ELOOP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EMFILE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EMSGSIZE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENAMETOOLONG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENETDOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENETUNREACH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENFILE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOBUFS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENODEV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOENT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOMEM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENONET</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOSPC</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOSYS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOTCONN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOTDIR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOTEMPTY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOTFOUND</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOTSOCK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ENOTSUP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EOF</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EPERM</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EPIPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EPROTO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EPROTONOSUPPORT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EPROTOTYPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EROFS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ESHUTDOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ESPIPE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ESRCH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_ETIMEDOUT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_EXDEV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>ERRNO_UNKNOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_100</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_101</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_102</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_200</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_201</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_202</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_203</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_204</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_205</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_206</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_207</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_208</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_226</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_300</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_301</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_302</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_303</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_304</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_305</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_307</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_308</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_400</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_401</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_402</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_403</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_404</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_405</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_406</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_407</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_408</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_409</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_410</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_411</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_412</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_413</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_414</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_415</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_416</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_417</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_418</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_421</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_422</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_423</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_424</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_425</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_426</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_428</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_429</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_431</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_451</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_500</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_501</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_502</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_503</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_504</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_505</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_506</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_507</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_508</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_509</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_510</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">broken-link-checker.</span>HTTP_511</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.HtmlChecker">module broken-link-checker.HtmlChecker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.HtmlChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.HtmlChecker.prototype">module broken-link-checker.HtmlChecker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.__getCache">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>__getCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.clearCache">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.numActiveLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>numActiveLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.numQueuedLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>numQueuedLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.pause">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.resume">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.scan">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>scan
            <span class="apidocSignatureSpan">(html, baseUrl, robots)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.HtmlUrlChecker">module broken-link-checker.HtmlUrlChecker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.HtmlUrlChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlUrlChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.HtmlUrlChecker.prototype">module broken-link-checker.HtmlUrlChecker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.__getCache">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>__getCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.clearCache">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.dequeue">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>dequeue
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.enqueue">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(pageUrl, customData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numActiveLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>numActiveLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numPages">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>numPages
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numQueuedLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>numQueuedLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.pause">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.resume">
            function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.SiteChecker">module broken-link-checker.SiteChecker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.SiteChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>SiteChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.SiteChecker.prototype">module broken-link-checker.SiteChecker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.clearCache">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.dequeue">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>dequeue
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.enqueue">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(firstPageUrl, customData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numActiveLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numActiveLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numPages">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numPages
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numQueuedLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numQueuedLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numSites">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numSites
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.pause">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.SiteChecker.prototype.resume">
            function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.UrlChecker">module broken-link-checker.UrlChecker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.UrlChecker">
            function <span class="apidocSignatureSpan">broken-link-checker.</span>UrlChecker
            <span class="apidocSignatureSpan">(options, handlers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.broken-link-checker.UrlChecker.prototype">module broken-link-checker.UrlChecker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.__getCache">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>__getCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.clearCache">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.dequeue">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>dequeue
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.enqueue">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(url, baseUrl, customData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.numActiveLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>numActiveLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.numQueuedLinks">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>numQueuedLinks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.pause">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.broken-link-checker.UrlChecker.prototype.resume">
            function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker" id="apidoc.module.broken-link-checker">module broken-link-checker</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker" id="apidoc.element.broken-link-checker.HtmlChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlChecker(options, handlers)
{
	var thisObj = this;
	
	reset(this);
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);
	
	this.urlChecker = new UrlChecker(this.options,
	{
		link: function(result)
		{
			maybeCallback(thisObj.handlers.link)(result);
		},
		end: function()
		{
			// If stream finished
			if (thisObj.parsed === true)
			{
				complete(thisObj);
			}
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
npm install broken-link-checker
```
The rest of this document will assist you with how to use the API.


## Classes

### `blc.<span class="apidocCodeKeywordSpan">HtmlChecker</span>(options, handlers)`
Scans an HTML document to find broken links.

* `handlers.complete` is fired after the last result or zero results.
* `handlers.html` is fired after the HTML document has been fully parsed.
  * `tree` is supplied by [parse5](https://npmjs.com/parse5)
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker" id="apidoc.element.broken-link-checker.HtmlUrlChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlUrlChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlUrlChecker(options, handlers)
{
	var thisObj = this;
	
	reset(this);
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);
	
	this.htmlUrlQueue = new RequestQueue(
	{
		maxSockets: 1,
		rateLimit: this.options.rateLimit
	},
	{
		item: function(input, done)
		{
			thisObj.currentCustomData = input.data.customData;
			thisObj.currentDone = done;
			thisObj.currentPageUrl = input.url;
			
			streamHtml(thisObj.currentPageUrl, thisObj.__getCache(), thisObj.options).then( function(result)
			{
				thisObj.currentResponse = result.response;
				
				thisObj.currentRobots = new RobotDirectives({ userAgent: thisObj.options.userAgent });
				
				robotHeaders(thisObj);
				
				// Passes robots instance so that headers are included in robot exclusion checks
				thisObj.htmlChecker.scan(result.stream, result.response.url, thisObj.currentRobots);
			})
			.catch( function(error)
			{
				completedPage(thisObj, error);
			});
		},
		end: function()
		{
			// Clear references for garbage collection
			reset(thisObj);
			
			maybeCallback(thisObj.handlers.end)();
		}
	});
	
	this.htmlChecker = new HtmlChecker(this.options,
	{
		html: function(tree, robots)
		{
			maybeCallback(thisObj.handlers.html)(tree, robots, thisObj.currentResponse, thisObj.currentPageUrl, thisObj.currentCustomData
);
		},
		_filter: function(result)
		{
			// Undocumented handler for excluding links via custom constraints
			return maybeCallback(thisObj.handlers._filter)(result);
		},
		junk: function(result)
		{
			maybeCallback(thisObj.handlers.junk)(result, thisObj.currentCustomData);
		},
		link: function(result)
		{
			maybeCallback(thisObj.handlers.link)(result, thisObj.currentCustomData);
		},
		complete: function()
		{
			completedPage(thisObj, null);
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	link: function(result){},
	complete: function(){}
});

htmlChecker.scan(html, baseUrl);
```

### `blc.<span class="apidocCodeKeywordSpan">HtmlUrlChecker</span>(options, handlers)`
Scans the HTML content at each queued URL to find broken links.

* `handlers.end` is fired when the end of the queue has been reached.
* `handlers.html` is fired after a page's HTML document has been fully parsed.
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker" id="apidoc.element.broken-link-checker.SiteChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>SiteChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SiteChecker(options, handlers)
{
	var thisObj = this;
	
	reset(this);
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);
	
	this.sitePagesChecked = new UrlCache({ expiryTime: this.options.cacheExpiryTime });
	
	this.siteUrlQueue = new RequestQueue(
	{
		maxSockets: 1,
		rateLimit: this.options.rateLimit
	},
	{
		item: function(input, done)
		{
			thisObj.currentCustomData = input.data.customData;
			thisObj.currentDone = done;
			thisObj.currentSiteUrl = input.url;  // TODO :: strip after hostname?
			
			// Support checking sites multiple times
			thisObj.sitePagesChecked.clear();
			
			if (options.honorRobotExclusions === true)
			{
				getRobotsTxt(thisObj.currentSiteUrl, options).then( function(robots)
				{
					thisObj.currentRobotsTxt = robots;
					
					maybeCallback(thisObj.handlers.robots)(robots, thisObj.currentCustomData);
				<span class="apidocCodeCommentSpan">/*})
				.catch( function(error)
				{
					maybeCallback(thisObj.handlers.robots)(error, null);
				})
				.then( function()
				{*/
</span>					enqueuePage(thisObj, thisObj.currentSiteUrl, thisObj.currentCustomData);
				});
			}
			else
			{
				enqueuePage(thisObj, thisObj.currentSiteUrl, thisObj.currentCustomData);
			}
		},
		end: function()
		{
			// Reduce memory usage
			thisObj.sitePagesChecked.clear();
			
			// Clear references for garbage collection
			reset(thisObj);
			
			maybeCallback(thisObj.handlers.end)();
		}
	});
	
	this.htmlUrlChecker = new HtmlUrlChecker(this.options,
	{
		html: function(tree, robots, response, pageUrl, customData)
		{
			// If was redirected
			if (response.url !== pageUrl)
			{
				thisObj.sitePagesChecked.set(response.url, true);
				
				for (var i=0; i&lt;response.redirects.length; i++)
				{
					// Avoid rechecking any redirected pages
					thisObj.sitePagesChecked.set( response.redirects[i].url, true );
				}
			}
			
			maybeCallback(thisObj.handlers.html)(tree, robots, response, pageUrl, customData);
		},
		_filter: function(result)  // undocumented handler
		{
			// Additional filters for excluding links
			return maybeCheckLink(thisObj, result);
		},
		junk: function(result, customData)
		{
			maybeCallback(thisObj.handlers.junk)(result, customData);
			
			maybeEnqueuePage(thisObj, result, customData);
		},
		link: function(result, customData)
		{
			maybeCallback(thisObj.handlers.link)(result, customData);
			
			maybeEnqueuePage(thisObj, result, customData);
		},
		page: function(error, pageUrl, customData)
		{
			maybeCallback(thisObj.handlers.page)(error, pageUrl, customData);
			
			// Only the first page should supply an error to "site" handler
			if (thisObj.sitePagesChecked.length() &lt;= 1)
			{
				thisObj.currentPageError = error;
			}
		},
		end: function()
		{
			maybeCallback(thisObj.handlers.site)(thisObj.currentPageError, thisObj.currentSiteUrl, thisObj.currentCustomData);
			
			// Auto-starts next site, if any
			// If not, fires "end"
			thisObj.currentDone();
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	page: function(error, pageUrl, customData){},
	end: function(){}
});

htmlUrlChecker.enqueue(pageUrl, customData);
```

### `blc.<span class="apidocCodeKeywordSpan">SiteChecker</span>(options, handlers)`
Recursively scans (crawls) the HTML content at each queued URL to find broken links.

* `handlers.end` is fired when the end of the queue has been reached.
* `handlers.html` is fired after a page's HTML document has been fully parsed.
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker" id="apidoc.element.broken-link-checker.UrlChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>UrlChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlChecker(options, handlers)
{
	var thisObj = this;
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);

	this.cache = new UrlCache(
	{
		expiryTime: this.options.cacheExpiryTime,
		normalizeUrls: false
	});
	
	this.linkQueue = new RequestQueue(
	{
		maxSockets:        this.options.maxSockets,
		maxSocketsPerHost: this.options.maxSocketsPerHost,
		rateLimit:         this.options.rateLimit
	},
	{
		item: function(input, done)
		{
			// TODO :: make this more reusable
			function handle_checkUrl(result)
			{
				maybeCallback(thisObj.handlers.link)(result, input.data.customData);
				
				// Auto-starts next queue item, if any
				// If not, fires "end"
				done();
			}
			
			if (input.data.linkObj !== undefined)
			{
				checkUrl(input.data.linkObj, null, thisObj.cache, thisObj.options).then(handle_checkUrl);
			}
			else
			{
				// TODO :: send url object -- remove orgUrl?
				checkUrl(input.data.orgUrl, input.data.baseUrl, thisObj.cache, thisObj.options).then(handle_checkUrl);
			}
		},
		end: function()
		{
			maybeCallback(thisObj.handlers.end)();
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	site: function(error, siteUrl, customData){},
	end: function(){}
});

siteChecker.enqueue(siteUrl, customData);
```

### `blc.<span class="apidocCodeKeywordSpan">UrlChecker</span>(options, handlers)`
Requests each queued URL to determine if they are broken.

* `handlers.end` is fired when the end of the queue has been reached.
* `handlers.link` is fired for each result (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a URL from the queue. Returns `true` on success or an `Error` on failure.
...</pre></li>
    </ul>
















































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.HtmlChecker" id="apidoc.module.broken-link-checker.HtmlChecker">module broken-link-checker.HtmlChecker</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.HtmlChecker" id="apidoc.element.broken-link-checker.HtmlChecker.HtmlChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlChecker(options, handlers)
{
	var thisObj = this;
	
	reset(this);
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);
	
	this.urlChecker = new UrlChecker(this.options,
	{
		link: function(result)
		{
			maybeCallback(thisObj.handlers.link)(result);
		},
		end: function()
		{
			// If stream finished
			if (thisObj.parsed === true)
			{
				complete(thisObj);
			}
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
npm install broken-link-checker
```
The rest of this document will assist you with how to use the API.


## Classes

### `blc.<span class="apidocCodeKeywordSpan">HtmlChecker</span>(options, handlers)`
Scans an HTML document to find broken links.

* `handlers.complete` is fired after the last result or zero results.
* `handlers.html` is fired after the HTML document has been fully parsed.
  * `tree` is supplied by [parse5](https://npmjs.com/parse5)
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.HtmlChecker.prototype" id="apidoc.module.broken-link-checker.HtmlChecker.prototype">module broken-link-checker.HtmlChecker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.__getCache" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.__getCache">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>__getCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__getCache = function ()
{
	return this.urlChecker.__getCache();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.clearCache" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.clearCache">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCache = function ()
{
	return this.urlChecker.clearCache();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.complete` is fired after the last result or zero results.
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.<span class="apidocCodeKeywordSpan">clearCache</span>()` will remove any cached URL responses. This is only relevant if the `
cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.numActiveLinks" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.numActiveLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>numActiveLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numActiveLinks = function ()
{
	return this.urlChecker.numActiveLinks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">numActiveLinks</span>()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.numQueuedLinks" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.numQueuedLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>numQueuedLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numQueuedLinks = function ()
{
	return this.urlChecker.numQueuedLinks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5)
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.<span class="apidocCodeKeywordSpan">numQueuedLinks</span>()` returns the number of links that currently have no active requests
.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.pause" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.pause">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function ()
{
	return this.urlChecker.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.<span class="apidocCodeKeywordSpan">pause</span>()` will pause the internal link queue, but will not pause any active requests
.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.resume" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.resume">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function ()
{
	return this.urlChecker.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.<span class="apidocCodeKeywordSpan">resume</span>()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
	html: function(tree, robots){},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlChecker.prototype.scan" id="apidoc.element.broken-link-checker.HtmlChecker.prototype.scan">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlChecker.prototype.</span>scan
        <span class="apidocSignatureSpan">(html, baseUrl, robots)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function (html, baseUrl, robots)
{
	var tree;
	var thisObj = this;
	
	if (this.active === false)
	{
		// Prevent user error with undocumented arugment
		if (robots instanceof RobotDirectives === false)
		{
			robots = new RobotDirectives({ userAgent: this.options.userAgent });
		}
		
		this.active = true;
		this.baseUrl = baseUrl;
		this.robots = robots;
		
		parseHtml(html).then( function(document)
		{
			tree = document;
			return scrapeHtml(document, thisObj.robots);
		})
		.then( function(links)
		{
			maybeCallback(thisObj.handlers.html)(tree, thisObj.robots);
			
			for (var i=0, numLinks=links.length; i&lt;numLinks; i++)
			{
				enqueueLink(links[i], thisObj);
			}
			
			thisObj.parsed = true;
			
			// If no links found or all links already checked
			if (thisObj.urlChecker.numActiveLinks()===0 &amp;&amp; thisObj.urlChecker.numQueuedLinks()===0)
			{
				complete(thisObj);
			}
		});
		
		return true;
	}
	
	return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.<span class="apidocCodeKeywordSpan">scan</span>(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false`
when there is a previously incomplete scan (and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
	html: function(tree, robots){},
	junk: function(result){},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.HtmlUrlChecker" id="apidoc.module.broken-link-checker.HtmlUrlChecker">module broken-link-checker.HtmlUrlChecker</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.HtmlUrlChecker" id="apidoc.element.broken-link-checker.HtmlUrlChecker.HtmlUrlChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>HtmlUrlChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HtmlUrlChecker(options, handlers)
{
	var thisObj = this;
	
	reset(this);
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);
	
	this.htmlUrlQueue = new RequestQueue(
	{
		maxSockets: 1,
		rateLimit: this.options.rateLimit
	},
	{
		item: function(input, done)
		{
			thisObj.currentCustomData = input.data.customData;
			thisObj.currentDone = done;
			thisObj.currentPageUrl = input.url;
			
			streamHtml(thisObj.currentPageUrl, thisObj.__getCache(), thisObj.options).then( function(result)
			{
				thisObj.currentResponse = result.response;
				
				thisObj.currentRobots = new RobotDirectives({ userAgent: thisObj.options.userAgent });
				
				robotHeaders(thisObj);
				
				// Passes robots instance so that headers are included in robot exclusion checks
				thisObj.htmlChecker.scan(result.stream, result.response.url, thisObj.currentRobots);
			})
			.catch( function(error)
			{
				completedPage(thisObj, error);
			});
		},
		end: function()
		{
			// Clear references for garbage collection
			reset(thisObj);
			
			maybeCallback(thisObj.handlers.end)();
		}
	});
	
	this.htmlChecker = new HtmlChecker(this.options,
	{
		html: function(tree, robots)
		{
			maybeCallback(thisObj.handlers.html)(tree, robots, thisObj.currentResponse, thisObj.currentPageUrl, thisObj.currentCustomData
);
		},
		_filter: function(result)
		{
			// Undocumented handler for excluding links via custom constraints
			return maybeCallback(thisObj.handlers._filter)(result);
		},
		junk: function(result)
		{
			maybeCallback(thisObj.handlers.junk)(result, thisObj.currentCustomData);
		},
		link: function(result)
		{
			maybeCallback(thisObj.handlers.link)(result, thisObj.currentCustomData);
		},
		complete: function()
		{
			completedPage(thisObj, null);
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	link: function(result){},
	complete: function(){}
});

htmlChecker.scan(html, baseUrl);
```

### `blc.<span class="apidocCodeKeywordSpan">HtmlUrlChecker</span>(options, handlers)`
Scans the HTML content at each queued URL to find broken links.

* `handlers.end` is fired when the end of the queue has been reached.
* `handlers.html` is fired after a page's HTML document has been fully parsed.
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.HtmlUrlChecker.prototype" id="apidoc.module.broken-link-checker.HtmlUrlChecker.prototype">module broken-link-checker.HtmlUrlChecker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.__getCache" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.__getCache">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>__getCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__getCache = function ()
{
	return this.htmlChecker.__getCache();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.clearCache" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.clearCache">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCache = function ()
{
	return this.htmlChecker.clearCache();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.complete` is fired after the last result or zero results.
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.<span class="apidocCodeKeywordSpan">clearCache</span>()` will remove any cached URL responses. This is only relevant if the `
cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.dequeue" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.dequeue">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>dequeue
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dequeue = function (id)
{
	return this.htmlUrlQueue.dequeue(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not) within the current page.
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">dequeue</span>(id)` removes a page from the queue. Returns `true` on success or an `Error
` on failure.
* `.enqueue(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued when their requests are complete. Returns
 a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.enqueue" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.enqueue">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(pageUrl, customData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueue = function (pageUrl, customData)
{
	return this.htmlUrlQueue.enqueue(
	{
		url: pageUrl,
		data: { customData:customData }
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not) within the current page.
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a page from the queue. Returns `true` on success or an `Error` on failure.
* `.<span class="apidocCodeKeywordSpan">enqueue</span>(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued
 when their requests are complete. Returns a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numActiveLinks" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numActiveLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>numActiveLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numActiveLinks = function ()
{
	return this.htmlChecker.numActiveLinks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">numActiveLinks</span>()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numPages" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numPages">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>numPages
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numPages = function ()
{
	return this.htmlUrlQueue.length();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a page from the queue. Returns `true` on success or an `Error` on failure.
* `.enqueue(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued when their requests are complete. Returns
 a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.<span class="apidocCodeKeywordSpan">numPages</span>()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.

```js
var htmlUrlChecker = new blc.HtmlUrlChecker(options, {
	html: function(tree, robots, response, pageUrl, customData){},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numQueuedLinks" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.numQueuedLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>numQueuedLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numQueuedLinks = function ()
{
	return this.htmlChecker.numQueuedLinks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5)
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.<span class="apidocCodeKeywordSpan">numQueuedLinks</span>()` returns the number of links that currently have no active requests
.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.pause" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.pause">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function ()
{
	this.htmlChecker.pause();
	return this.htmlUrlQueue.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.<span class="apidocCodeKeywordSpan">pause</span>()` will pause the internal link queue, but will not pause any active requests
.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.resume" id="apidoc.element.broken-link-checker.HtmlUrlChecker.prototype.resume">
        function <span class="apidocSignatureSpan">broken-link-checker.HtmlUrlChecker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function ()
{
	this.htmlChecker.resume();
	return this.htmlUrlQueue.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.<span class="apidocCodeKeywordSpan">resume</span>()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
	html: function(tree, robots){},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.SiteChecker" id="apidoc.module.broken-link-checker.SiteChecker">module broken-link-checker.SiteChecker</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.SiteChecker" id="apidoc.element.broken-link-checker.SiteChecker.SiteChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>SiteChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SiteChecker(options, handlers)
{
	var thisObj = this;
	
	reset(this);
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);
	
	this.sitePagesChecked = new UrlCache({ expiryTime: this.options.cacheExpiryTime });
	
	this.siteUrlQueue = new RequestQueue(
	{
		maxSockets: 1,
		rateLimit: this.options.rateLimit
	},
	{
		item: function(input, done)
		{
			thisObj.currentCustomData = input.data.customData;
			thisObj.currentDone = done;
			thisObj.currentSiteUrl = input.url;  // TODO :: strip after hostname?
			
			// Support checking sites multiple times
			thisObj.sitePagesChecked.clear();
			
			if (options.honorRobotExclusions === true)
			{
				getRobotsTxt(thisObj.currentSiteUrl, options).then( function(robots)
				{
					thisObj.currentRobotsTxt = robots;
					
					maybeCallback(thisObj.handlers.robots)(robots, thisObj.currentCustomData);
				<span class="apidocCodeCommentSpan">/*})
				.catch( function(error)
				{
					maybeCallback(thisObj.handlers.robots)(error, null);
				})
				.then( function()
				{*/
</span>					enqueuePage(thisObj, thisObj.currentSiteUrl, thisObj.currentCustomData);
				});
			}
			else
			{
				enqueuePage(thisObj, thisObj.currentSiteUrl, thisObj.currentCustomData);
			}
		},
		end: function()
		{
			// Reduce memory usage
			thisObj.sitePagesChecked.clear();
			
			// Clear references for garbage collection
			reset(thisObj);
			
			maybeCallback(thisObj.handlers.end)();
		}
	});
	
	this.htmlUrlChecker = new HtmlUrlChecker(this.options,
	{
		html: function(tree, robots, response, pageUrl, customData)
		{
			// If was redirected
			if (response.url !== pageUrl)
			{
				thisObj.sitePagesChecked.set(response.url, true);
				
				for (var i=0; i&lt;response.redirects.length; i++)
				{
					// Avoid rechecking any redirected pages
					thisObj.sitePagesChecked.set( response.redirects[i].url, true );
				}
			}
			
			maybeCallback(thisObj.handlers.html)(tree, robots, response, pageUrl, customData);
		},
		_filter: function(result)  // undocumented handler
		{
			// Additional filters for excluding links
			return maybeCheckLink(thisObj, result);
		},
		junk: function(result, customData)
		{
			maybeCallback(thisObj.handlers.junk)(result, customData);
			
			maybeEnqueuePage(thisObj, result, customData);
		},
		link: function(result, customData)
		{
			maybeCallback(thisObj.handlers.link)(result, customData);
			
			maybeEnqueuePage(thisObj, result, customData);
		},
		page: function(error, pageUrl, customData)
		{
			maybeCallback(thisObj.handlers.page)(error, pageUrl, customData);
			
			// Only the first page should supply an error to "site" handler
			if (thisObj.sitePagesChecked.length() &lt;= 1)
			{
				thisObj.currentPageError = error;
			}
		},
		end: function()
		{
			maybeCallback(thisObj.handlers.site)(thisObj.currentPageError, thisObj.currentSiteUrl, thisObj.currentCustomData);
			
			// Auto-starts next site, if any
			// If not, fires "end"
			thisObj.currentDone();
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	page: function(error, pageUrl, customData){},
	end: function(){}
});

htmlUrlChecker.enqueue(pageUrl, customData);
```

### `blc.<span class="apidocCodeKeywordSpan">SiteChecker</span>(options, handlers)`
Recursively scans (crawls) the HTML content at each queued URL to find broken links.

* `handlers.end` is fired when the end of the queue has been reached.
* `handlers.html` is fired after a page's HTML document has been fully parsed.
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.SiteChecker.prototype" id="apidoc.module.broken-link-checker.SiteChecker.prototype">module broken-link-checker.SiteChecker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.clearCache" id="apidoc.element.broken-link-checker.SiteChecker.prototype.clearCache">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCache = function ()
{
	// Does not clear `sitePagesChecked` because it would mess up any current scans
	return this.htmlUrlChecker.clearCache();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.complete` is fired after the last result or zero results.
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.<span class="apidocCodeKeywordSpan">clearCache</span>()` will remove any cached URL responses. This is only relevant if the `
cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.dequeue" id="apidoc.element.broken-link-checker.SiteChecker.prototype.dequeue">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>dequeue
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dequeue = function (id)
{
	return this.siteUrlQueue.dequeue(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not) within the current page.
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">dequeue</span>(id)` removes a page from the queue. Returns `true` on success or an `Error
` on failure.
* `.enqueue(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued when their requests are complete. Returns
 a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.enqueue" id="apidoc.element.broken-link-checker.SiteChecker.prototype.enqueue">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(firstPageUrl, customData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueue = function (firstPageUrl, customData)
{
	return this.siteUrlQueue.enqueue(
	{
		url: firstPageUrl,
		data: { customData:customData }
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not) within the current page.
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a page from the queue. Returns `true` on success or an `Error` on failure.
* `.<span class="apidocCodeKeywordSpan">enqueue</span>(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued
 when their requests are complete. Returns a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numActiveLinks" id="apidoc.element.broken-link-checker.SiteChecker.prototype.numActiveLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numActiveLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numActiveLinks = function ()
{
	return this.htmlUrlChecker.numActiveLinks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">numActiveLinks</span>()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numPages" id="apidoc.element.broken-link-checker.SiteChecker.prototype.numPages">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numPages
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numPages = function ()
{
	return this.htmlUrlChecker.numPages();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a page from the queue. Returns `true` on success or an `Error` on failure.
* `.enqueue(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued when their requests are complete. Returns
 a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.<span class="apidocCodeKeywordSpan">numPages</span>()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.

```js
var htmlUrlChecker = new blc.HtmlUrlChecker(options, {
	html: function(tree, robots, response, pageUrl, customData){},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numQueuedLinks" id="apidoc.element.broken-link-checker.SiteChecker.prototype.numQueuedLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numQueuedLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numQueuedLinks = function ()
{
	return this.htmlUrlChecker.numQueuedLinks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5)
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.<span class="apidocCodeKeywordSpan">numQueuedLinks</span>()` returns the number of links that currently have no active requests
.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.numSites" id="apidoc.element.broken-link-checker.SiteChecker.prototype.numSites">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>numSites
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numSites = function ()
{
	return this.siteUrlQueue.length();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a site from the queue. Returns `true` on success or an `Error` on failure.
* `.enqueue(siteUrl, customData)` adds [the first page of] a site to the queue. Queue items are auto-dequeued when their requests
 are complete. Returns a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the site.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.<span class="apidocCodeKeywordSpan">numSites</span>()` returns the total number of sites in the queue.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.

**Note:** `options.filterLevel` is used for determining which links are recursive.

```js
var siteChecker = new blc.SiteChecker(options, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.pause" id="apidoc.element.broken-link-checker.SiteChecker.prototype.pause">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function ()
{
	this.htmlUrlChecker.pause();
	return this.siteUrlQueue.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.<span class="apidocCodeKeywordSpan">pause</span>()` will pause the internal link queue, but will not pause any active requests
.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.SiteChecker.prototype.resume" id="apidoc.element.broken-link-checker.SiteChecker.prototype.resume">
        function <span class="apidocSignatureSpan">broken-link-checker.SiteChecker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function ()
{
	this.htmlUrlChecker.resume();
	return this.siteUrlQueue.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.<span class="apidocCodeKeywordSpan">resume</span>()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
	html: function(tree, robots){},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.UrlChecker" id="apidoc.module.broken-link-checker.UrlChecker">module broken-link-checker.UrlChecker</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.UrlChecker" id="apidoc.element.broken-link-checker.UrlChecker.UrlChecker">
        function <span class="apidocSignatureSpan">broken-link-checker.</span>UrlChecker
        <span class="apidocSignatureSpan">(options, handlers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UrlChecker(options, handlers)
{
	var thisObj = this;
	
	this.handlers = handlers || {};
	this.options = options = parseOptions(options);

	this.cache = new UrlCache(
	{
		expiryTime: this.options.cacheExpiryTime,
		normalizeUrls: false
	});
	
	this.linkQueue = new RequestQueue(
	{
		maxSockets:        this.options.maxSockets,
		maxSocketsPerHost: this.options.maxSocketsPerHost,
		rateLimit:         this.options.rateLimit
	},
	{
		item: function(input, done)
		{
			// TODO :: make this more reusable
			function handle_checkUrl(result)
			{
				maybeCallback(thisObj.handlers.link)(result, input.data.customData);
				
				// Auto-starts next queue item, if any
				// If not, fires "end"
				done();
			}
			
			if (input.data.linkObj !== undefined)
			{
				checkUrl(input.data.linkObj, null, thisObj.cache, thisObj.options).then(handle_checkUrl);
			}
			else
			{
				// TODO :: send url object -- remove orgUrl?
				checkUrl(input.data.orgUrl, input.data.baseUrl, thisObj.cache, thisObj.options).then(handle_checkUrl);
			}
		},
		end: function()
		{
			maybeCallback(thisObj.handlers.end)();
		}
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	site: function(error, siteUrl, customData){},
	end: function(){}
});

siteChecker.enqueue(siteUrl, customData);
```

### `blc.<span class="apidocCodeKeywordSpan">UrlChecker</span>(options, handlers)`
Requests each queued URL to determine if they are broken.

* `handlers.end` is fired when the end of the queue has been reached.
* `handlers.link` is fired for each result (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a URL from the queue. Returns `true` on success or an `Error` on failure.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.broken-link-checker.UrlChecker.prototype" id="apidoc.module.broken-link-checker.UrlChecker.prototype">module broken-link-checker.UrlChecker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.__getCache" id="apidoc.element.broken-link-checker.UrlChecker.prototype.__getCache">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>__getCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__getCache = function ()
{
	return this.cache;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.clearCache" id="apidoc.element.broken-link-checker.UrlChecker.prototype.clearCache">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCache = function ()
{
	return this.cache.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.complete` is fired after the last result or zero results.
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.<span class="apidocCodeKeywordSpan">clearCache</span>()` will remove any cached URL responses. This is only relevant if the `
cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.dequeue" id="apidoc.element.broken-link-checker.UrlChecker.prototype.dequeue">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>dequeue
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dequeue = function (id)
{
	return this.linkQueue.dequeue(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5).
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not) within the current page.
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">dequeue</span>(id)` removes a page from the queue. Returns `true` on success or an `Error
` on failure.
* `.enqueue(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued when their requests are complete. Returns
 a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.enqueue" id="apidoc.element.broken-link-checker.UrlChecker.prototype.enqueue">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(url, baseUrl, customData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueue = function (url, baseUrl, customData)
{
	// Undocumented internal use: enqueue(linkObj)
	if (isString(url)===false &amp;&amp; url.broken_link_checker===true)
	{
		return this.linkQueue.enqueue(
		{
			url: url.url.parsed,
			data: { customData:customData, linkObj:url }
		});
	}
	// Documented use: enqueue(url, baseUrl)
	// or erroneous and let linkQueue sort it out
	else
	{
		return this.linkQueue.enqueue(
		{
			url: urlobj.resolve(baseUrl || "", urlobj.parse(url) ),  // URL must be absolute
			data: { orgUrl:url, baseUrl:baseUrl, customData:customData }
		});
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` and `X-Robots
-Tag` robot exclusions.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not) within the current page.
* `handlers.page` is fired after a page's last result, on zero results, or if the HTML could not be retrieved.

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.dequeue(id)` removes a page from the queue. Returns `true` on success or an `Error` on failure.
* `.<span class="apidocCodeKeywordSpan">enqueue</span>(pageUrl, customData)` adds a page to the queue. Queue items are auto-dequeued
 when their requests are complete. Returns a queue ID on success or an `Error` on failure.
  * `customData` is optional data that is stored in the queue item for the page.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numPages()` returns the total number of pages in the queue.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the queue, but will not pause any active requests.
* `.resume()` will resume the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.numActiveLinks" id="apidoc.element.broken-link-checker.UrlChecker.prototype.numActiveLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>numActiveLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numActiveLinks = function ()
{
	return this.linkQueue.numActive();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.html` is fired after the HTML document has been fully parsed.
* `tree` is supplied by [parse5](https://npmjs.com/parse5)
* `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.<span class="apidocCodeKeywordSpan">numActiveLinks</span>()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
* `html` can be a stream or a string.
* `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.numQueuedLinks" id="apidoc.element.broken-link-checker.UrlChecker.prototype.numQueuedLinks">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>numQueuedLinks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numQueuedLinks = function ()
{
	return this.linkQueue.numQueued();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `tree` is supplied by [parse5](https://npmjs.com/parse5)
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.<span class="apidocCodeKeywordSpan">numQueuedLinks</span>()` returns the number of links that currently have no active requests
.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.pause" id="apidoc.element.broken-link-checker.UrlChecker.prototype.pause">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function ()
{
	return this.linkQueue.pause();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  * `robots` is an instance of [robot-directives](https://npmjs.com/robot-directives) containing any `&lt;meta&gt;` robot exclusions
.
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.<span class="apidocCodeKeywordSpan">pause</span>()` will pause the internal link queue, but will not pause any active requests
.
* `.resume()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.broken-link-checker.UrlChecker.prototype.resume" id="apidoc.element.broken-link-checker.UrlChecker.prototype.resume">
        function <span class="apidocSignatureSpan">broken-link-checker.UrlChecker.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function ()
{
	return this.linkQueue.resume();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `handlers.junk` is fired with data on each skipped link, as configured in options.
* `handlers.link` is fired with the result of each discovered link (broken or not).

* `.clearCache()` will remove any cached URL responses. This is only relevant if the `cacheResponses` option is enabled.
* `.numActiveLinks()` returns the number of links with active requests.
* `.numQueuedLinks()` returns the number of links that currently have no active requests.
* `.pause()` will pause the internal link queue, but will not pause any active requests.
* `.<span class="apidocCodeKeywordSpan">resume</span>()` will resume the internal link queue.
* `.scan(html, baseUrl)` parses &amp; scans a single HTML document. Returns `false` when there is a previously incomplete scan (
and `true` otherwise).
  * `html` can be a stream or a string.
  * `baseUrl` is the address to which all relative URLs will be made absolute. Without a value, links to relative URLs will output
 an "Invalid URL" error.

```js
var htmlChecker = new blc.HtmlChecker(options, {
	html: function(tree, robots){},
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>